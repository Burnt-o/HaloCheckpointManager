#include "pch.h"
#include "Invulnerability.h"
#include "ModuleHook.h"
#include "MultilevelPointer.h"
#include "MidhookContextInterpreter.h"
#include "PointerDataStore.h"
#include "SettingsStateAndEvents.h"
#include "Datum.h"
#include "RuntimeExceptionHandler.h"
#include "DIContainer.h"
#include "IMCCStateHook.h"
#include "GetPlayerDatum.h"
#include "IMakeOrGetCheat.h"
#include "GetObjectAddress.h"
#include "DynamicStructFactory.h"
#include "MidhookFlagInterpreter.h"

struct boardingMechanicInfo
{
	bool gameHasBoarding = false;
	int32_t boardingTextFlagValueWhenFalse = 0x1;
};

template <GameState::Value game, boardingMechanicInfo boardingInfo> // templated only so we can have seperate versions of the static vars per game
class SimpleInvulnerabilityImpl : public InvulnerabilityImpl//, public std::enable_shared_from_this<SimpleInvulnerabilityImpl<game, boardingInfo>>
{
public:
	static inline std::mutex mDestructionGuard{};


	GameState mGame;
	// event callbacks
	ScopedCallback<ToggleEvent> mInvulnerabilityToggleCallbackHandle;

	// injected services
	std::weak_ptr<IMCCStateHook> mccStateHookWeak;
	std::weak_ptr<IMessagesGUI> messagesGUIWeak;
	std::shared_ptr<RuntimeExceptionHandler> runtimeExceptions;
	std::weak_ptr<SettingsStateAndEvents> settingsWeak;
	std::weak_ptr< GetPlayerDatum> getPlayerDatumWeak;
	std::weak_ptr< GetObjectAddress> getObjectAddressWeak;

	//data
	static inline std::shared_ptr<ModuleMidHook> invulnerabilityHook;
	static inline std::shared_ptr<MultilevelPointer> invulnerabilityFunction;
	static inline std::shared_ptr<MidhookContextInterpreter> invulnerabilityFunctionContext;
	static inline std::shared_ptr< MidhookFlagInterpreter> invulnerabilityFunctionFlagSetter;
	enum class bipedDataFields { currentVehicleDatum };
	std::shared_ptr<DynamicStruct<bipedDataFields>> playerDataStruct;
	std::optional<std::shared_ptr<MultilevelPointer>> boardingText;
	std::optional<std::shared_ptr<MultilevelPointer>> boardingTextFlag;



	static void makeInvulnerable(SafetyHookContext& ctx)
	{
		LOG_ONCE(PLOG_DEBUG << "making object invulnerable");
		invulnerabilityFunctionFlagSetter->setFlag(ctx);
	}

	constexpr static std::array<std::wstring_view, 2> boardingTextsToCheck() { return { L"to melee", L"to plant" }; }

	static bool playerIsBoarding()
	{
		if (!instance->boardingText.has_value() || !instance->boardingTextFlag.has_value()) { LOG_ONCE(PLOG_DEBUG << "optional boarding pointers lacked values"); return false; }
		std::wstring resolvedBoardingText;
		int32_t resolvedBoardingTextFlag;
		if (!instance->boardingText.value()->readData(&resolvedBoardingText)) { LOG_ONCE(PLOG_DEBUG << "could not resolve boarding text"); return false; }
		if (!instance->boardingTextFlag.value()->readData(&resolvedBoardingTextFlag)) { LOG_ONCE(PLOG_DEBUG << "could not resolve boarding text flag"); return false; }
		if (resolvedBoardingTextFlag == boardingInfo.boardingTextFlagValueWhenFalse) { LOG_ONCE(PLOG_DEBUG << "boarding text was not active"); return false; }

		LOG_ONCE_CAPTURE(PLOG_DEBUG << "evaluating boarding text, current val: " << text, text = resolvedBoardingText);

		//todo: add multilevelpointer_readPlainString and check for containing rel text


			//constexpr std::wstring_view actualBoardingText1 = L"to melee";
			//constexpr std::wstring_view actualBoardingText2 = L"to plant";

		for (auto& check : boardingTextsToCheck())
		{
			if (resolvedBoardingText.contains(check)) return true;
		}
		return false;

	}

	static void invulnerabilityHookFunction(SafetyHookContext& ctx)
	{
		std::unique_lock<std::mutex> lock(mDestructionGuard);
		LOG_ONCE(PLOG_DEBUG << "invulnerabilityHookFunction running");
		try
		{

			lockOrThrow(instance->settingsWeak, settings);
			lockOrThrow(instance->getPlayerDatumWeak, getPlayerDatum);
			lockOrThrow(instance->getObjectAddressWeak, getObjectAddress);

			if (settings->invulnerabilityNPCToggle->GetValue())
			{
				// when this option checked, we make EVERYTHING invuln- no need to check what's getting damaged
				return makeInvulnerable(ctx);
			}

			enum class param
			{
				currentlyDamagedUnitDatum
			};
			auto* ctxInterpreter = invulnerabilityFunctionContext.get();
			LOG_ONCE_CAPTURE(PLOG_DEBUG << "resolvedParam: " << resolvedParam, resolvedParam = ctxInterpreter->getParameterRef(ctx, (int)param::currentlyDamagedUnitDatum));

			Datum currentlyDamagedUnitDatum = *(Datum*)ctxInterpreter->getParameterRef(ctx, (int)param::currentlyDamagedUnitDatum);
			Datum playersCurrentDatum = getPlayerDatum->getPlayerDatum();


			if (playersCurrentDatum.isNull() || currentlyDamagedUnitDatum.isNull()) return; // might happen when the player is dead, depending on game version / pointer used

			// check if current actor is player
			if (currentlyDamagedUnitDatum == playersCurrentDatum)
			{
#ifdef  HCM_DEBUG
				PLOG_DEBUG << "play datum: " << playersCurrentDatum;
				CommonObjectType outObjectType = CommonObjectType::FailedTypeConversion;

				auto debugPlayerAddress = getObjectAddress->getObjectAddress(playersCurrentDatum, &outObjectType);
				PLOG_DEBUG << "play address: " << std::hex << debugPlayerAddress
					<< "\n objectType: " << magic_enum::enum_name(outObjectType)
					<< "\n (as int: " << (int)outObjectType << ")";
#endif //  HCM_DEBUG

				return makeInvulnerable(ctx);
			}

			LOG_ONCE_CAPTURE(PLOG_DEBUG << "playersCurrentDatum: " << datum, datum = playersCurrentDatum);

			// update address of players biped data

			CommonObjectType outPlayerObjectType;
			auto playerAddress = getObjectAddress->getObjectAddress(playersCurrentDatum, &outPlayerObjectType);

			if (outPlayerObjectType != CommonObjectType::Biped) throw HCMRuntimeException(std::format("Player object type mismatch! got: {} (as int: {})", magic_enum::enum_name(outPlayerObjectType), (int)outPlayerObjectType));

			LOG_ONCE_CAPTURE(PLOG_DEBUG << "updating playerDataStructs currentBaseAddress: " << std::hex << addy, addy = playerAddress);
			instance->playerDataStruct->currentBaseAddress = playerAddress;

			// get current vehicle datum
			LOG_ONCE(PLOG_DEBUG << "looking up playersCurrentVehicleDatum");
			Datum playersCurrentVehicleDatum = *instance->playerDataStruct->field<Datum>(bipedDataFields::currentVehicleDatum);
			LOG_ONCE_CAPTURE(PLOG_DEBUG << "playersCurrentVehicleDatum: " << datum, datum = playersCurrentVehicleDatum);

			// if the current damaged unit is the players current vehicle, make invuln!
			if (currentlyDamagedUnitDatum == playersCurrentVehicleDatum)
			{
#ifdef  HCM_DEBUG
				PLOG_DEBUG << "vehi datum: " << playersCurrentVehicleDatum;
				CommonObjectType outObjectType;
				PLOG_DEBUG << "vehi address: " << std::hex << (uint64_t)getObjectAddress->getObjectAddress(playersCurrentVehicleDatum, &outObjectType)
					<< "\n objectType: " << magic_enum::enum_name(outObjectType);
#endif //  HCM_DEBUG



				// check if the player is actually BOARDING this vehicle, in which case we don't want to make it invuln
				if constexpr (boardingInfo.gameHasBoarding)
				{
					if (!playerIsBoarding())
					{
						LOG_ONCE_CAPTURE(PLOG_VERBOSE << "making players vehicle invuln!: " << datum, datum = currentlyDamagedUnitDatum);
						return makeInvulnerable(ctx);
					}
					else
					{
						LOG_ONCE_CAPTURE(PLOG_VERBOSE << "not making players boarded vehicle invuln!: " << datum, datum = currentlyDamagedUnitDatum);
						return;
					}
				}
				else
				{
					LOG_ONCE_CAPTURE(PLOG_VERBOSE << "making players vehicle invuln!: " << datum, datum = currentlyDamagedUnitDatum);
					return makeInvulnerable(ctx);
				}



			}

			LOG_ONCE_CAPTURE(PLOG_VERBOSE << "not making invulnerable: " << datum, datum = currentlyDamagedUnitDatum);
#ifdef HCM_DEBUG
			PLOG_VERBOSE << "not making invulnerable: " << currentlyDamagedUnitDatum; 
#endif
		}
		catch (HCMRuntimeException ex)
		{
			instance->runtimeExceptions->handleMessage(ex);
#ifndef HCM_DEBUG
			instance->settingsWeak.lock()->invulnerabilityToggle.get()->flipBoolSetting();
#endif // !HCM_DEBUG


		}




	}

	virtual void onInvulnToggle(bool& newVal)
	{
		try
		{
			lockOrThrow(messagesGUIWeak, messagesGUI);
			lockOrThrow(mccStateHookWeak, mccStateHook);

			PLOG_DEBUG << "onInvulnToggle: newval: " << newVal;
			invulnerabilityHook->setWantsToBeAttached(newVal);
			if (mccStateHook->isGameCurrentlyPlaying(mGame))
			{
				messagesGUI->addMessage(newVal ? "Invulnerability enabled." : "Invulnerability disabled.");
			}
		}
		catch (HCMRuntimeException ex)
		{
			runtimeExceptions->handleMessage(ex);
		}


	}




	static inline SimpleInvulnerabilityImpl<game, boardingInfo>* instance = nullptr;

	SimpleInvulnerabilityImpl(GameState game, IDIContainer& dicon)
		: mGame(game),
		settingsWeak(dicon.Resolve<SettingsStateAndEvents>()),
		mInvulnerabilityToggleCallbackHandle(dicon.Resolve<SettingsStateAndEvents>().lock()->invulnerabilityToggle->valueChangedEvent, [this](bool& newval) { onInvulnToggle(newval); }),
		mccStateHookWeak(dicon.Resolve<IMCCStateHook>()),
		messagesGUIWeak(dicon.Resolve<IMessagesGUI>()),
		runtimeExceptions(dicon.Resolve<RuntimeExceptionHandler>()),
		getPlayerDatumWeak(resolveDependentCheat(GetPlayerDatum)),
		getObjectAddressWeak(resolveDependentCheat(GetObjectAddress))
	{
		if (instance) throw HCMInitException(std::format("Cannot have more than one SimpleInvulnerabilityImpl per game, game: {}", game.toString()));

		auto ptr = dicon.Resolve<PointerDataStore>().lock();
		playerDataStruct = DynamicStructFactory::make<bipedDataFields>(ptr, game);
		invulnerabilityFunction = ptr->getData<std::shared_ptr<MultilevelPointer>>(nameof(invulnerabilityFunction), game);
		invulnerabilityFunctionContext = ptr->getData<std::shared_ptr<MidhookContextInterpreter>>(nameof(invulnerabilityFunctionContext), game);
		invulnerabilityFunctionFlagSetter = ptr->getData<std::shared_ptr<MidhookFlagInterpreter>>(nameof(invulnerabilityFunctionFlagSetter), game);
		invulnerabilityHook = ModuleMidHook::make(game.toModuleName(), invulnerabilityFunction, invulnerabilityHookFunction);


		if constexpr (boardingInfo.gameHasBoarding)
		{
			try
			{
				boardingText = std::make_optional<std::shared_ptr<MultilevelPointer>>(ptr->getData<std::shared_ptr<MultilevelPointer>>(nameof(boardingText), game));
				boardingTextFlag = std::make_optional<std::shared_ptr<MultilevelPointer>>(ptr->getData<std::shared_ptr<MultilevelPointer>>(nameof(boardingTextFlag), game));
			}
			catch (HCMInitException ex)
			{
				PLOG_ERROR << "no boarding text/flag available for game: " << game.toString() << ", error: " << ex.what() << "\nBoarded vehicles will unfortunately be invulnerable.";
			}
		}

		instance = this;


	}

	~SimpleInvulnerabilityImpl()
	{
		PLOG_DEBUG << "~SimpleInvulnerabilityImpl";
		//mInvulnerabilityToggleCallbackHandle.~ScopedCallback(); // no new callback invokes
		invulnerabilityHook->setWantsToBeAttached(false);
		//invulnerabilityHook.reset(); // no new hook invokes
		std::unique_lock<std::mutex> lock(mDestructionGuard); // block until callbacks/hooks finish executing
		instance = nullptr;
	}

};



class H2InvulnerabilityImpl : public SimpleInvulnerabilityImpl<GameState::Value::Halo2, boardingMechanicInfo(true, 0xFFFFFFFF) >
{
protected:
	static inline std::mutex mDestructionGuard2{};


	//data
	static inline std::shared_ptr<ModuleMidHook> fallTimerInvulnerabilityHook;
	static inline std::shared_ptr<MultilevelPointer> fallTimerInvulnerabilityFunction;
	static inline std::shared_ptr<MidhookContextInterpreter> fallTimerInvulnerabilityFunctionContext;
	static inline std::shared_ptr< MidhookFlagInterpreter> fallTimerInvulnerabilityFunctionFlagSetter;

	static void makeFallingInvulnerable(SafetyHookContext& ctx)
	{
		LOG_ONCE(PLOG_DEBUG << "making object fall-timer invulnerable");
		fallTimerInvulnerabilityFunctionFlagSetter->setFlag(ctx);
	}

	static void fallTimerInvulnerabilityHookFunction(SafetyHookContext& ctx)
	{

		std::unique_lock<std::mutex> lock(mDestructionGuard2);
		LOG_ONCE(PLOG_DEBUG << "fallTimerInvulnerabilityHookFunction running");
		try
		{


			lockOrThrow(instance->settingsWeak, settings);
			lockOrThrow(instance->getPlayerDatumWeak, getPlayerDatum);
			lockOrThrow(instance->getObjectAddressWeak, getObjectAddress);

			if (settings->invulnerabilityNPCToggle->GetValue())
			{
				// when this option checked, we make EVERYTHING invuln- no need to check what's getting damaged
				return makeFallingInvulnerable(ctx);
			}

			enum class param
			{
				currentlyDamagedUnitDatum
			};
			auto* ctxInterpreter = fallTimerInvulnerabilityFunctionContext.get();
			LOG_ONCE_CAPTURE(PLOG_DEBUG << "resolvedParam: " << resolvedParam, resolvedParam = ctxInterpreter->getParameterRef(ctx, (int)param::currentlyDamagedUnitDatum));

			Datum currentlyDamagedUnitDatum = *(Datum*)ctxInterpreter->getParameterRef(ctx, (int)param::currentlyDamagedUnitDatum);
			Datum playersCurrentDatum = getPlayerDatum->getPlayerDatum();


			if (playersCurrentDatum.isNull() || currentlyDamagedUnitDatum.isNull()) return; // might happen when the player is dead, depending on game version / pointer used

			// check if current actor is player
			if (currentlyDamagedUnitDatum == playersCurrentDatum)
			{
#ifdef  HCM_DEBUG
				PLOG_DEBUG << "play datum: " << playersCurrentDatum;
				CommonObjectType outObjectType = CommonObjectType::FailedTypeConversion;

				auto debugPlayerAddress = getObjectAddress->getObjectAddress(playersCurrentDatum, &outObjectType);
				PLOG_DEBUG << "play address: " << std::hex << debugPlayerAddress
					<< "\n objectType: " << magic_enum::enum_name(outObjectType)
					<< "\n (as int: " << (int)outObjectType << ")";
#endif //  HCM_DEBUG

				return makeFallingInvulnerable(ctx);
			}

			LOG_ONCE_CAPTURE(PLOG_DEBUG << "playersCurrentDatum: " << datum, datum = playersCurrentDatum);

			// update address of players biped data

			CommonObjectType outPlayerObjectType;
			auto playerAddress = getObjectAddress->getObjectAddress(playersCurrentDatum, &outPlayerObjectType);

			if (outPlayerObjectType != CommonObjectType::Biped) throw HCMRuntimeException(std::format("Player object type mismatch! got: {} (as int: {})", magic_enum::enum_name(outPlayerObjectType), (int)outPlayerObjectType));

			LOG_ONCE_CAPTURE(PLOG_DEBUG << "updating playerDataStructs currentBaseAddress: " << std::hex << addy, addy = playerAddress);
			instance->playerDataStruct->currentBaseAddress = playerAddress;

			// get current vehicle datum
			LOG_ONCE(PLOG_DEBUG << "looking up playersCurrentVehicleDatum");
			Datum playersCurrentVehicleDatum = *instance->playerDataStruct->field<Datum>(bipedDataFields::currentVehicleDatum);
			LOG_ONCE_CAPTURE(PLOG_DEBUG << "playersCurrentVehicleDatum: " << datum, datum = playersCurrentVehicleDatum);

			// if the current damaged unit is the players current vehicle, make invuln!
			if (currentlyDamagedUnitDatum == playersCurrentVehicleDatum)
			{
#ifdef  HCM_DEBUG
				PLOG_DEBUG << "vehi datum: " << playersCurrentVehicleDatum;
				CommonObjectType outObjectType;
				PLOG_DEBUG << "vehi address: " << std::hex << (uint64_t)getObjectAddress->getObjectAddress(playersCurrentVehicleDatum, &outObjectType)
					<< "\n objectType: " << magic_enum::enum_name(outObjectType);
#endif //  HCM_DEBUG

			
					LOG_ONCE_CAPTURE(PLOG_VERBOSE << "making players vehicle invuln!: " << datum, datum = currentlyDamagedUnitDatum);
					return makeFallingInvulnerable(ctx);



			}

			LOG_ONCE_CAPTURE(PLOG_VERBOSE << "not making invulnerable: " << datum, datum = currentlyDamagedUnitDatum);
#ifdef HCM_DEBUG
			PLOG_VERBOSE << "not making invulnerable: " << currentlyDamagedUnitDatum;
#endif
		}
		catch (HCMRuntimeException ex)
		{
			instance->runtimeExceptions->handleMessage(ex);
#ifndef HCM_DEBUG
			instance->settingsWeak.lock()->invulnerabilityToggle.get()->flipBoolSetting();
#endif // !HCM_DEBUG
		}
	}


public:
	H2InvulnerabilityImpl(GameState game, IDIContainer& dicon)
		: SimpleInvulnerabilityImpl<GameState::Value::Halo2, boardingMechanicInfo(true, 0xFFFFFFFF)>(game, dicon)
	{
		auto ptr = dicon.Resolve<PointerDataStore>().lock();

		fallTimerInvulnerabilityFunction = ptr->getData<std::shared_ptr<MultilevelPointer>>(nameof(fallTimerInvulnerabilityFunction), game);
		fallTimerInvulnerabilityFunctionContext = ptr->getData<std::shared_ptr<MidhookContextInterpreter>>(nameof(fallTimerInvulnerabilityFunctionContext), game);
		fallTimerInvulnerabilityFunctionFlagSetter = ptr->getData<std::shared_ptr<MidhookFlagInterpreter>>(nameof(fallTimerInvulnerabilityFunctionFlagSetter), game);
		fallTimerInvulnerabilityHook = ModuleMidHook::make(game.toModuleName(), fallTimerInvulnerabilityFunction, fallTimerInvulnerabilityHookFunction);
	
	}

	void onInvulnToggle(bool& newVal) override
	{
		try
		{
			lockOrThrow(messagesGUIWeak, messagesGUI);
			lockOrThrow(mccStateHookWeak, mccStateHook);

			PLOG_DEBUG << "onInvulnToggle: newval: " << newVal;
			invulnerabilityHook->setWantsToBeAttached(newVal);
			fallTimerInvulnerabilityHook->setWantsToBeAttached(newVal);

			if (mccStateHook->isGameCurrentlyPlaying(mGame))
			{
				messagesGUI->addMessage(newVal ? "Invulnerability enabled." : "Invulnerability disabled.");
			}
		}
		catch (HCMRuntimeException ex)
		{
			runtimeExceptions->handleMessage(ex);
		}


	}

	~H2InvulnerabilityImpl()
	{
		PLOG_DEBUG << "~H2InvulnerabilityImpl";
		fallTimerInvulnerabilityHook->setWantsToBeAttached(false);
		std::unique_lock<std::mutex> lock(mDestructionGuard2); // block until callbacks/hooks finish executing
		instance = nullptr;
	}

};



Invulnerability::Invulnerability(GameState game, IDIContainer& dicon)
{
	std::lock_guard<std::mutex> lock(constructionMutex);
	if (pimpl) return;

	switch (game)
	{
	case GameState::Value::Halo1:
		pimpl = std::make_unique < SimpleInvulnerabilityImpl < GameState::Value::Halo1, boardingMechanicInfo(false, 0) >>(game, dicon);
	break;

	case GameState::Value::Halo2:
		pimpl = std::make_unique<H2InvulnerabilityImpl>(game, dicon);
		break;

	case GameState::Value::Halo3:
		pimpl = std::make_unique<SimpleInvulnerabilityImpl<GameState::Value::Halo3, boardingMechanicInfo(true, 0x0)>>(game, dicon);
		break;

	case GameState::Value::Halo3ODST:
		pimpl = std::make_unique<SimpleInvulnerabilityImpl<GameState::Value::Halo3ODST, boardingMechanicInfo(true, 0x0)>>(game, dicon);
		break;

	case GameState::Value::HaloReach:
		pimpl = std::make_unique<SimpleInvulnerabilityImpl<GameState::Value::HaloReach, boardingMechanicInfo(true, 0x0)>>(game, dicon);
		break;

	case GameState::Value::Halo4:
		pimpl = std::make_unique<SimpleInvulnerabilityImpl<GameState::Value::Halo4, boardingMechanicInfo(true, 0x0)>>(game, dicon);
		break;

	default:
		throw HCMInitException("Unimplemented game");
	}
}

Invulnerability::~Invulnerability()
{
	PLOG_VERBOSE << "~" << getName();
	pimpl.reset();
}
